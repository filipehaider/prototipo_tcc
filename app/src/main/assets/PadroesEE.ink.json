{"inkVersion":20,"root":[["^Era uma vez...","\n","^Seu nome é Edward De Sign e você acabou de ser contratado para o cargo de arquiteto Java EE da empresa AvajOdnum. Essa empresa multinacional indiana possui uma grande aplicação que roda na internet e provê serviços para diversas empresas que pagam pela sua utilização. Não foram dados muitos detalhes no momento de sua contratação, mas parece que sua primeira tarefa será o projeto de um módulo para a inserção de notificações de chamadas em métodos já existentes na aplicação. A vaga foi bem disputada, então você, de alguma forma, sente o peso da responsabilidade para a geração de um resultado positivo o mais rápido possível. Pronto para o primeiro dia de trabalho?","\n","^Você chega na empresa no seu primeiro dia e é recebido com muito entusiasmo e expectativa por seus novos colegas. Na parte da manhã, você é apresentado à sua equipe de trabalho e se acomoda na sala onde irá trabalhar, realizando tarefas de um recém-chegado como criação de credenciais de segurança e configuração de ambiente. Na parte da tarde, você é chamado a uma reunião na qual será explicada a arquitetura do sistema com o qual irá trabalhar e qual será sua primeira tarefa.","\n","^Quando já estava esperando que a arquitetura do sistema com o qual irá trabalhar fosse “arcaica” e amarrada a antigos padrões de mercado, você se depara com uma boa surpresa: o sistema está implementado utilizando EJB 3 e JPA. O sistema possui um módulo web implementado em JSF e um módulo desktop implementado em Swing que utilizam as interfaces remotas dos EJBs de sessão para o acesso as funcionalidades do sistema. No servidor de aplicações, existe uma camada de EJBs destinada a realizar o acesso a base de dados utilizando JPA, funcionando como uma camada de DAOs. Acima dessa camada, existem EJBs que executam regras de negócio das funcionalidades e acessam a camada de EJBs de acesso a dados quando necessário As camadas de EJBs para acesso a dados disponibilizam apenas interfaces locais, enquanto a outra camada apenas interfaces remotas.","\n","^Devido ao fato da aplicação ser disponibilizada para outras empresas, diversas necessidades específicas surgem em cada um dos clientes, muitas vezes relacionadas com a integração com sistemas existentes. Esse tipo de requisição motivou a gerência a dar importância para a implementação de um mecanismo na arquitetura que permitisse que funcionalidades fossem invocadas antes ou depois da chamada de funcionalidades na camada de negócios, ou seja, nos EJBs remotos da aplicação.","\n","^Não é necessário que essas chamadas influam na execução da funcionalidade. A princípio elas apenas devem notificar a execução da funcionalidade. Exemplos de uso desse novo recurso citados na reunião foram: gravação de trilha de auditoria em bancos de dados ou em arquivos, acionamento de gatilhos de processos em servidores de workflow, chamadas a sistemas externos e envios de e-mail de notificação. O projeto de como isso será implementado na aplicação será seu primeiro desafio nesse cargo de arquiteto. O projeto se dividirá em três fases, nas quais haverá a implementação e em seguida a implantação no servidor em produção. Segue o que será abordado em cada fase:","\n","^Fase 1 – Integração do mecanismo de notificação nas funcionalidades existente;","\n","^Fase 2 – Definição da forma de tratamento das notificações;","\n","^Fase 3 – Flexibilização do mecanismo para inserção de novas notificações.","\n","^A primeira questão que deverá ser tratada é como a notificação deverá ser integrada na aplicação já existente de forma a gerar o menor impacto possível no que já está implementado. Neste cenário, surgem algumas alternativas a serem seguidas:","\n",["ev",{"^->":"0.20.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":"0.c-0","flg":2},{"s":["^Se você acha que qualquer decisão agora será muito precipitada e deseja se reunir com a equipe para explorar melhor os requisitos não-funcionais, vá para (4);",{"->":"$r","var":true},null]}],["ev",{"^->":"0.21.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":"0.c-1","flg":2},{"s":["^Se você acha qua a melhor forma de integrar essas notificações é utilizando a injeção de dependência do EJB container para injetar um Session Bean que deve ser chamado dentro dos métodos para que a notificação seja feita, vá para (2);",{"->":"$r","var":true},null]}],["ev",{"^->":"0.22.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":"0.c-2","flg":2},{"s":["^Se você prefere implementar a notificação dentro de interceptores para executarem em torno da execução dos métodos do EJBs, vá para (7).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":"0.20.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_4"},{"->":"0.g-0"},{"#f":5}],"c-1":["ev",{"^->":"0.c-1.$r2"},"/ev",{"temp=":"$r"},{"->":"0.21.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_2"},{"->":"0.g-0"},{"#f":5}],"c-2":["ev",{"^->":"0.c-2.$r2"},"/ev",{"temp=":"$r"},{"->":"0.22.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_7"},{"->":"0.g-0"},{"#f":5}],"g-0":["done",{"#f":5}]}],"done",{"Opcao_2":[["^Você decide que o mecanismo de notificação será implementado em um Session Bean, chamado de Notificador, o qual deve ser injetado pelo container dentro dos EJBs já existentes na aplicação. Dentro dos métodos dos EJBs, deve ser feita uma chamada a métodos do Notificador passando as informações do contexto da chamada do método, como o seu nome, o EJB ao qual pertence, os parâmetros recebidos e o usuário que o executou.","\n","^Para a implantação desse primeiro passo foi escolhida uma funcionalidade simples, porém importante, para ser implantada: o registro de auditoria em arquivo (ou seja, a gravação do log da execução das funcionalidades do sistema). Ela servirá para testar se o mecanismo de notificação está corretamente inserido na aplicação para que outras questões possam ser tratadas.","\n","^O Session Bean Notificador foi implementado facilmente para realizar as tarefas de auditoria. Para que o mesmo possa ser utilizado por outros beans, bastou utilizar a injeção de dependência do container. Um atributo do tipo da interface do Notificador com a anotação @EJB foi inserido nos session beans que precisavam utilizar a auditoria. A chamada ao Notificador precisou ser inserida em cada um dos métodos de cada um dos EJBs. Esta estratégia se mostrou flexível devido a facilidade de adicionar a chamada em qualquer ponto da execução do método. Um ponto negativo foi que, apesar da lógica de processamento estar no bean Notificador, ele ainda precisa ser invocado dentro de cada método, o que gerou um maior acoplamento e um enorme trabalho braçal por parte dos desenvolvedores.","\n","^Foi um pouco mais de uma semana de trabalho intenso de toda equipe para inserir o mecanismo em toda a aplicação. Mesmo com tanto esforço, alguns métodos acabaram sendo esquecidos e outros implementados de forma errada. Depois da implementação estar pronta, ainda foi mais uma semana com diversos testes cobrindo toda a aplicação, nos quais diversas pequenas falhas foram detectadas. Mesmo depois dos testes, você ainda se sente um pouco inseguro se está tudo realmente correto.","\n","^A equipe ficou insatisfeita em precisar executar um trabalho braçal em toda a aplicação. A gerência esperava que a implantação desse mecanismo inicial fosse mais rápida e ficou decepcionada com o número de erros que foram encontrados na fase de testes. Talvez a solução escolhida não tenha sido a ideal, porém depois de tanto trabalho não dava mais para voltar atrás. Você sente que suas decisões em relação a outras questões do mecanismo de notificação serão críticas para seu futuro na empresa.","\n","^O bean notificador agora está implementando diretamente a funcionalidade de auditoria, mas a intenção é que ele seja apenas um gerenciador que recebe essas chamadas e redireciona para quem deve fazer o tratamento. Outro aspecto que deve ser considerado é a transacionalidade, pois a notificação só deve ser feita caso a funcionalidade seja executada com sucesso. Neste momento, existem duas opções a respeito de como as notificações serão redirecionadas:","\n",["ev",{"^->":"Opcao_2.0.12.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Se você acha que as notificações devem ser enviadas de forma assíncrona para um Message-Driven Bean tratar, vá para (5);",{"->":"$r","var":true},null]}],["ev",{"^->":"Opcao_2.0.13.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-1","flg":2},{"s":["^Se você acha que o EJB Notificator deve ser utilizado como fachada para funcionalidade de notifcação e delegar a execução da lógica para classes auxiliares, vá para (8).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"Opcao_2.0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.12.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_5"},{"#f":5}],"c-1":["ev",{"^->":"Opcao_2.0.c-1.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.13.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_8"},{"#f":5}]}],{"#f":1}],"Opcao_3":[["^A decisão tomada acaba dando um peso maior para sua preocupação com desempenho e você decide realizar uma chamada assíncrona para tratar a notificação, o que é um padrão conhecido como Service Activator. Dessa forma, o interceptor irá enviar uma mensagem para um servidor de mensagens, que será recebida por um Message-driven Bean, o qual será responsável pelo processamento da notificação.","\n","^Como forma de testar esse novo passo do desenvolvimento será implantada a primeira integração com o sistema de um dos maiores clientes da AvajOdnum. O cliente disponibilizou um web service em um dos seus sistemas para ser invocado na chamada de algumas funcionalidades. Não se sabe exatamente qual funcionalidade será executada pela aplicação dele. A princípio serão utilizadas condicionais simples para definir quais chamadas deverão invocar o serviço do cliente, porém isso deve ser mudado na última fase da implantação do mecanismo de notificações.","\n","^A funcionalidade de auditoria foi transferida para um Messagedriven Bean que trata mensagens recebidas de uma fila do servidor de mensagens. O envio da mensagem é feito pelo interceptor Notificador que antes implementava a funcionalidade diretamente. A chamada ao web service do cliente é feita, a princípio, diretamente do Message-driven Bean e o filtro por funcionalidade é feito utilizando condicionais no próprio código.","\n","^A criação da funcionalidade foi rapidamente feita por você mesmo e nos testes realizados não houve degradação do desempenho da aplicação. Em alguns períodos do dia o serviço do cliente acaba ficando um pouco lento e demorando a responder, porém como isso é tratado assincronamente, esse fato não interfere no tempo de execução percebido pelos usuários. O envio da mensagem é incluído na transação distribuída do container e só é efetivado caso não seja dado rollback na mesma. Isso é especialmente útil para notificações realizadas antes da execução da funcionalidade, quando no momento da notificação ainda não se sabe se haverá algum problema que poderá anular a transação.","\n","^Havia certo receio na equipe e na gerência que as chamadas a funcionalidades de outras aplicações fossem degradar o desempenho, porém com a solução da chamada assíncrona você mostrou que é possível fazer isso mantendo o tempo de resposta da aplicação. Você ganha o respeito de todos, que depositam em você a confiança para concluir a funcionalidade de notificação.","\n","^A próxima decisão a ser tomada irá influenciar a facilidade de adição de novas ações a serem acionadas pela notificação. No momento, estão implementadas as funcionalidades de auditoria e a chamada a aplicação de um dos clientes, porém você sabe que várias outras ações serão inseridas no futuro. Atualmente condicionais no próprio código verificam as condições de execução de cada tipo de notificação, porém você deve criar um mecanismo que facilite a adição desse tipo de funcionalidade. É preciso levar em consideração que mais de uma ação pode ser realizada a partir de uma notificação e que pode haver lógicas comuns em funcionalidades de notificação diferentes. Qual será a estratégia que você irá escolher para fazer isso?","\n",["ev",{"^->":"Opcao_3.0.12.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Se você deseja criar um Message-driven Bean que define um algoritmo no método onMessage() que chama métodos abstratos para serem implementados por várias subclasses usando o padrão Template Method, vá para (13);",{"->":"$r","var":true},null]}],["ev",{"^->":"Opcao_3.0.13.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-1","flg":2},{"s":["^Se você deseja criar apenas um Message-driven Bean que chama outros objetos encadeados para o tratamento das mensagens usando o padrão Chain of Responsibility, vá para (17).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"Opcao_3.0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.12.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_13"},{"#f":5}],"c-1":["ev",{"^->":"Opcao_3.0.c-1.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.13.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_17"},{"#f":5}]}],{"#f":1}],"Opcao_4":[["^Antes de tomar uma decisão a respeito de como deve ser a implementação, você decide reunir a equipe e realizar um brainstorm a respeito de quais os requisitos não-funcionais mais importantes. Além de obter informações importantes sobre os requisitos, você também ganhou o respeito da equipe por tê-la incluído no processo de modelagem da arquitetura. No final da reunião foram sumarizados os seguintes requisitos não-funcionais:","\n",["^Desempenho: a aplicação executa atualmente no limite máximo do desempenho que é permitido pelos requisitos e alguns clientes chegam a reclamar de lentidão em horários de pico. Não é desejável que o mecanismo de notificação cause uma degradação perceptível no desempenho das funcionalidades já existentes.","\n",["^Desacoplamento: o sistema atual é muito grande e uma implementação que criasse a necessidade de alteração em diversas classes do sistema seria muito cara e trabalhosa. O mecanismo de notificação deve ser o mais desacoplado possível das classes já existentes no sistema.","\n",["^Flexibilidade: diversos clientes que utilizam o sistema já comentaram a respeito da necessidade do envio de notificações para sistemas proprietários. Quando o mecanismo estiver pronto, será necessário a implementação de diferentes tipos de notificações para os diferentes clientes. Sendo assim, o processo de criação de tipos de notificação deve ser simples, flexível e configurável.","\n",["^Transacionalidade: uma notificação só pode ser efetuada caso a funcionalidade seja executada sem que tenha sido dado um rollback na transação.","\n","^Depois da conversa com a equipe, você se sente mais confiante e com mais informações para tomar decisões a respeito da arquitetura do sistema. Qual será sua decisão a respeito de como o mecanismo de notificação deve ser integrado ao sistema?","\n",["ev",{"^->":"Opcao_4.0.g-0.g-1.g-2.g-3.4.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Se você acha que a melhor forma de integrar essas formas de notificações é utilizando a injeção de dependência do EJB container para injetar um Session Bean que deve ser chamado dentro dos métodos para que a notificação seja feita, vá para (2);",{"->":"$r","var":true},null]}],["ev",{"^->":"Opcao_4.0.g-0.g-1.g-2.g-3.5.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-1","flg":2},{"s":["^Se você prefere implementar a notificação dentro de interceptors para executarem em torno da execução dos métodos do EJBs, vá para (7).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"Opcao_4.0.g-0.g-1.g-2.g-3.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.4.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_2"},{"#f":5}],"c-1":["ev",{"^->":"Opcao_4.0.g-0.g-1.g-2.g-3.c-1.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.5.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_7"},{"#f":5}],"#f":5,"#n":"g-3"}],{"#f":5,"#n":"g-2"}],{"#f":5,"#n":"g-1"}],{"#f":5,"#n":"g-0"}],null],{"#f":1}],"Opcao_5":[["^A decisão tomada acaba dando um peso maior para sua preocupação com desempenho e você decide realizar uma chamada assíncrona para tratar a notificação, o que é um padrão conhecido como Service Activator. Dessa forma, o Session Bean Notificador irá enviar uma mensagem para um servidor de mensagens, que será recebida por um Message-driven Bean, o qual será responsável pelo processamento da notificação.","\n","^Como forma de testar esse novo passo do desenvolvimento será implantada a primeira integração com o sistema de um dos maiores clientes da AvajOdnum. O cliente disponibilizou um web service em um dos seus sistemas para ser invocado na chamada de algumas funcionalidades. Não se sabe exatamente qual funcionalidade será executada pela aplicação dele. A princípio serão utilizadas condicionais simples para definir quais chamadas deverão invocar o serviço do cliente, porém isso deve ser mudado na última fase da implantação do mecanismo de notificações.","\n","^A funcionalidade de auditoria foi transferida para um Message-driven Bean que trata mensagens recebidas de uma fila do servidor de mensagens. O envio da mensagem é feito pelo Session Bean Notificador que antes implementava a funcionalidade diretamente. A chamada ao web service do cliente é feita, a princípio, diretamente do Message-driven Bean e o filtro por funcionalidade é feito utilizando condicionais no próprio código.","\n","^A criação da funcionalidade foi rapidamente feita por você mesmo e nos testes realizados não houve degradação do desempenho da aplicação. Em alguns períodos do dia o serviço do cliente acaba ficando um pouco lento e demorando a responder, porém como isso é tratado assincronamente, esse fato não interfere no tempo de execução percebido pelos usuários. O envio da mensagem é incluído na transação distribuída do container e só é efetivado caso não seja dado rollback na mesma. Isso é especialmente útil para notificações realizadas antes da execução da funcionalidade, quando no momento da notificação ainda não se sabe se haverá algum problema que poderá anular a transação.","\n","^Havia certo receio na equipe e na gerência que a chamada a funcionalidade de outras aplicações fosse degradar o desempenho, porém com a solução da chamada assíncrona você mostrou que é possível fazer isso mantendo o tempo de resposta da aplicação. Com essa solução, você recupera o respeito da equipe e da gerência que havia em parte sido perdido depois da implantação da primeira parte do mecanismo de notificação. Você sente que seu sucesso na próxima decisão será crítico para seu futuro na empresa.","\n","^A próxima decisão a ser tomada irá influenciar a facilidade de adição de novas ações a serem acionadas pela notificação. No momento, estão implementadas as funcionalidades de auditoria e a chamada a aplicação de um dos clientes, porém você sabe que várias outras ações serão inseridas no futuro. Atualmente condicionais no próprio código verificam as condições de execução de cada tipo de notificação, porém você deve criar um mecanismo que facilite a adição desse tipo de funcionalidade. É preciso levar em consideração que mais de uma ação pode ser realizada a partir de uma notificação e que pode haver lógicas comuns em funcionalidades de notificação diferentes. Qual será a estratégia que você irá escolher para fazer isso?","\n",["ev",{"^->":"Opcao_5.0.12.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Se você deseja criar um Message-driven Bean que define um algoritmo no método onMessage() que chama métodos abstratos para serem implementados por várias subclasses usando o padrão Template Method, vá para (16);",{"->":"$r","var":true},null]}],["ev",{"^->":"Opcao_5.0.13.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-1","flg":2},{"s":["^Se você deseja criar apenas um Message-driven Bean que chama outros objetos encadeados para o tratamento das mensagens usando o padrão Chain of Responsibility, vá para (11).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"Opcao_5.0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.12.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_16"},{"#f":5}],"c-1":["ev",{"^->":"Opcao_5.0.c-1.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.13.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_11"},{"#f":5}]}],{"#f":1}],"Opcao_6":["^Quando você entra na sala do gerente, ele está trabalhando em seu computador. Ele a princípio parece ignorar sua presença, mas em seguida volta-se para você encarando-o com uma expressão bem séria. Para sua felicidade, ele alivia a pressão do momento com um sorriso e pede para você se sentar. Após fazer algumas perguntas sem muita importância para quebrar o gelo, ele diz que o motivo de ter te chamado era para falar do seu desempenho até o momento e falar sobre o seu futuro na empresa:","\n","^\"Nós aqui na AvajOdnum achamos que o seu desempenho ficou dentro de nossas expectativas iniciais. Apesar de você ter tomado decisões inteligentes e que realmente ajudaram na implementação do mecanismo de notificação de um de nossos sistemas, você mesmo sabe que essas decisões não foram sempre corretas que houveram algumas consequências negativas.\"","\n","^Você balança a cabeça admitindo que nem todas suas decisões foram as melhores e ele continua:","\n","^\"Estamos em um processo de expansão no qual adiquirimos outra empresa e precisaremos integrar os nossos sistemas com os sistemas deles. Para isso, estamos criando a posição de arquiteto corporativo em nossa empresa. Queremos que você continue atuando como arquiteto nessa aplicação e que interaja com o novo arquiteto corporativo nessa integração. É muito importante que você sempre discuta com ele as mudanças que você fizer na arquitetura, pois ele terá uma visão mais global de nossas aplicações.\"","\n","^Após a conversa, você volta para sua mesa em parte feliz, porque apesar do erro que você cometeu, ainda irá manter sua posição como arquiteto. Por outro lado, você percebe que se não fosse a decisão errada que tomou, poderia ser você a assumir o cargo de arquiteto corporativo. Você segue em frente, esperando que o desafio da integração dos sistemas e a troca de experiências com o novo arquiteto corporativo possam te ensinar bastante a respeito da modelagem da arquitetura de sistemas.","\n","end",{"#f":1}],"Opcao_7":[["^Você decide criar um interceptor, que é uma classe que pode interceptar chamadas de um EJB, para a criação do mecanismo de notificação. Essa classe deve ser definida no descritor XML da aplicação como um interceptor default para todos os Session Beans.","\n","^Para a implantação desse primeiro passo foi escolhida uma funcionalidade simples, porém importante, para ser implantada: o registro de auditoria em arquivo (ou seja, a gravação do log da execução das funcionalidades do sistema). Ela servirá para testar se o mecanismo de notificação está corretamente inserido na aplicação para que outras questões possam ser tratadas.","\n","^O interceptor, chamado de Notificador, foi implementado facilmente para realizar as tarefas de auditoria e através das configurações ele passou a ser chamado antes e depois da invocação de todos os métodos. Uma das vantagens dessa abordagem foi o baixo acoplamento desse novo mecanismo com os Session Beans já existentes na aplicação, que não precisaram ser alterados. Um problema encontrado foi a falta de flexibilidade, pois devido a mesma classe interceptar todos os métodos fica difícil de saber, por exemplo, se a notificação deve ser feita antes ou depois da execução do método.","\n","^Para a resolução desse problema, seguindo a filosofia da arquitetura do EJB 3, foram criadas anotações @NotifyBefore, @NotifyAfter e @NoNotification que permitiam configurar quando uma notificação seria enviada. Para evitar configurações em todos os métodos, a notificação depois da execução, que era o caso mais comum foi considerado o caso default. As anotações também poderiam ser utilizadas na classe, servindo, nesse caso, como uma configuração para todos os métodos, a não ser que existisse uma anotação específica nele. Esse tipo de estratégica no uso de anotações é utilizada no EJB 3 para gerenciamento de transações, segurança entre outros.","\n","^Não se pode dizer que foi rápido para inserir as configurações em toda a aplicação, porém o que deu mais trabalho foi percorrer todas as classes de serviço analisando se a notificação era necessária e em que momento ela deveria ser realizada. Em dois dias de dedicação da equipe de desenvolvimento, o sistema de notificação já estava implantado em toda a aplicação e em mais dois dias os testes revelaram que a implementação havia sido um sucesso.","\n","^Todos da equipe ficaram surpresos e satisfeitos com a solução, pois nenhum deles havia pensado na solução de usar uma combinação dos interceptors com as anotações. O código da notificação ficou bem desacoplado das classes da aplicação e a manutenção do mecanismo e inserção da notificação em novos Session Beans serão tarefas bem tranquilas. A gerência ficou satisfeita com o resultado da sua primeira semana de trabalho, pois eles não esperavam que a inserção desse novo componente na arquitetura já existente fosse ser tão rápida. Você fica feliz com seu primeiro acerto, porém sabe que o mecanismo não está completo e ainda existem várias decisões pela frente.","\n","^O interceptor Notificador agora está implementando diretamente a funcionalidade de auditoria, mas a intenção é que ele seja apenas um gerenciador que recebe essas chamadas e redireciona para quem deve fazer o tratamento. Outro aspecto que deve ser considerado é a transacionalidade, pois a notificação só deve ser feita caso a funcionalidade seja executada com sucesso. Neste momento, existem duas opções a respeito de como as notificações serão redirecionadas:","\n",["ev",{"^->":"Opcao_7.0.14.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Se você acha que as notificações devem ser enviadas de forma assíncrona para um Message-Driven Bean tratar, vá para (3);",{"->":"$r","var":true},null]}],["ev",{"^->":"Opcao_7.0.15.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-1","flg":2},{"s":["^Se você acha que as notificações devem ser redirecionadas para um Session Bean que serve como fachada para funcionalidade de notificação, vá para (10).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"Opcao_7.0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.14.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_3"},{"#f":5}],"c-1":["ev",{"^->":"Opcao_7.0.c-1.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.15.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_10"},{"#f":5}]}],{"#f":1}],"Opcao_8":[["^A decisão tomada acaba dando um peso maior para sua preocupação com a divisão de responsabilidades entre as classes e você decide tornar o Session Bean Notificador em um serviço de notificação conforme o padrão Application Service. Essa classe coordena e encapsula a invocação de serviços e classes de negócio que implementam a funcionalidade de cada notificação.","\n","^Como forma de testar esse novo passo do desenvolvimento será implantada a primeira integração com o sistema de um dos maiores clientes da AvajOdnum. O cliente disponibilizou um web service em um dos seus sistemas para ser invocado na chamada de algumas funcionalidades. Não se sabe exatamente qual funcionalidade será executada pela aplicação dele. A princípio serão utilizadas condicionais simples para definir quais chamadas deverão invocar o serviço do cliente, porém isso deve ser mudado na última fase da implantação do mecanismo de notificações.","\n","^A funcionalidade de auditoria foi transferida para uma classe auxiliar responsável por receber as informações do método invocado e adicionar as informações em um arquivo. Uma classe equivalente foi criada para encapsular a chamada do web service do cliente. O Session Bean Notificador com o serviço de notificação seleciona a classe auxiliar que será chamada utilizando condicionais no próprio código.","\n","^A criação da funcionalidade foi rapidamente feita por você mesmo e em alguns testes realizados houve, como já era esperado, um pequeno aumento no tempo de resposta da aplicação considerado aceitável. Depois que a modificação foi para o servidor de produção, em alguns períodos do dia o serviço do cliente acaba ficando um pouco lento e demorando a responder, o que impactou diretamente no desempenho da aplicação percebido pelos usuários.","\n","^Outro ponto problemático na solução foi o gerenciamento de transações. Em casos que a notificação acontecia antes da execução da funcionalidade e o serviço era invocado, não havia como avisar o sistema do cliente do erro caso houvesse um rollback na transação, pois ele não é transacional. Houve um dia em que um processo foi disparado na aplicação do cliente a partir da chamada no web service e houve um rollback da transação depois. Nem precisa dizer que foi a maior confusão para consertar o problema.","\n","^Essa implementação concretizou um dos maiores receios da gerência que a inserção das notificações traria problemas para o desempenho da aplicação. Diversas reclamações dos clientes, tanto por causa da demora na execução das funcionalidades quanto pelo problema com a transação, ajudaram a aumentar a pressão na empresa. Esse já é a sua segunda decisão que traz consequências negativas para a aplicação e você começa a sentir que “sua batata está assando”. Com isso, você sabe que seu próximo passo será decisivo para sua carreira na empresa.","\n","^A próxima decisão a ser tomada irá influenciar a facilidade de adição de novas ações a serem acionadas pela notificação. No momento, estão implementadas as funcionalidades de auditoria e a chamada a aplicação de um dos clientes, porém você sabe que várias outras ações serão inseridas no futuro. Atualmente condicionais no próprio código verificam as condições de execução de cada tipo de notificação, porém você deve criar um mecanismo que facilite a adição desse tipo de funcionalidade. É preciso levar em consideração que mais de uma ação pode ser realizada a partir de uma notificação e que pode haver lógicas comuns em funcionalidades de notificação diferentes. Qual será a estratégia que você irá escolher para fazer isso?","\n",["ev",{"^->":"Opcao_8.0.14.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Se você deseja criar uma superclasse para o tratamento das notificações que chama métodos abstratos para serem implementados por várias subclasses usando o padrão Template Method, vá para (14);",{"->":"$r","var":true},null]}],["ev",{"^->":"Opcao_8.0.15.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-1","flg":2},{"s":["^Se você deseja possiblitar o encadeamento dos objetos rsponsáveis pelo tratamento das mensagens usando o padrão Chain of Responsibility, vá para (20).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"Opcao_8.0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.14.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_14"},{"#f":5}],"c-1":["ev",{"^->":"Opcao_8.0.c-1.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.15.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_20"},{"#f":5}]}],{"#f":1}],"Opcao_9":["^Quando você entra na sala do gerente, ele está trabalhando em seu computador. Ele a princípio parece ignorar sua presença, mas em seguida volta-se para você encarando-o com uma expressão bem séria. Ele pede para você se sentar e sem fazer muitos rodeios diz que o motivo de ter te chamado era para falar do seu desempenho até o momento e falar sobre o seu futuro na empresa:","\n","^\"Infelizmente a notícia que temos para você não é boa. Nós aqui na AvajOdnum achamos que o seu desempenho ficou muito abaixo de nossas expectativas. Todas as suas decisões para a implementação do mecanismo de notificação tiveram consequências negativas para o nosso negócio. Muito trabalho braçal e demora no desenvolvimento, degradação no desempenho, duplicação de código, problemas com manutenção. Infelizmente não consigo enxergar nenhum motivo para manter você em nossa equipe. Gostaria de pedir que você passasse no RH para acertar a sua situação.\"","\n","^Você fica bastante chateado por ter sido demitido, mas por outro lado reconhece que nenhuma de suas decisões foi boa para a aplicação. Talvez você ainda não esteja preparado para assumir uma função de arquiteto e ainda precise estudar bastante para chegar a esse ponto. O mercado está cheio de oportunidades e resta a você agora começar novamente em outra empresa procurando aprender com os erros que cometeu.","\n","end",{"#f":1}],"Opcao_10":[["^A decisão tomada acaba dando um peso maior para sua preocupação com a divisão de responsabilidades entre as classes e você decide fazer o interceptor Notificador invocar um EJB, que será utilizado como um serviço de notificação conforme o padrão Application Service. Essa classe coordena e encapsula a invocação de serviços e classes de negócio que implementam a funcionalidade de cada notificação.","\n","^Como forma de testar esse novo passo do desenvolvimento será implantada a primeira integração com o sistema de um dos maiores clientes da AvajOdnum. O cliente disponibilizou um web service em um dos seus sistemas para ser invocado na chamada de algumas funcionalidades. Não se sabe exatamente qual funcionalidade será executada pela aplicação dele. A princípio serão utilizadas condicionais simples para definir quais chamadas deverão invocar o serviço do cliente, porém isso deve ser mudado na última fase da implantação do mecanismo de notificações.","\n","^O interceptor recebe agora injeção de dependência do EJB com o serviço de notificação e delega todas as chamadas para ele. A funcionalidade de auditoria foi transferida para uma classe auxiliar responsável por receber as informações do método invocado e adicionar as informações em um arquivo. Uma classe equivalente foi criada para encapsular a chamada do web service do cliente. O Session Bean com o serviço de notificação seleciona a classe auxiliar que será chamada utilizando condicionais no próprio código.","\n","^A criação da funcionalidade foi rapidamente feita por você mesmo e em alguns testes realizados houve, como já era esperado, um pequeno aumento no tempo de resposta da aplicação considerado aceitável. Depois que a modificação foi para o servidor de produção, em alguns períodos do dia o serviço do cliente acaba ficando um pouco lento e demorando a responder, o que impactou diretamente no desempenho da aplicação percebido pelos usuários.","\n","^Outro ponto problemático na solução foi o gerenciamento de transações. Em um caso que a notificação acontecia antes da execução da funcionalidade e o serviço era invocado, não havia como avisar o sistema do cliente do erro caso houvesse um rollback na transação, pois ele não é transacional. Houve um dia em que um processo foi disparado na aplicação do cliente a partir da chamada no web service e houve um rollback da transação depois. Nem precisa dizer que foi a maior confusão para consertar o problema.","\n","^Essa implementação concretizou um dos maiores receios da gerência que a inserção das notificações traria problemas para o desempenho da aplicação. Diversas reclamações dos clientes, tanto por causa da demora na execução das funcionalidades quanto pelo problema com a transação, ajudaram a aumentar a pressão na empresa. Apesar de você ter acertado na sua primeira decisão, essa segunda causou certo desconforto no ambiente de trabalho. Você percebe nesse momento que seu próximo passo pode ser decisivo para sua carreira na empresa.","\n","^A próxima decisão a ser tomada irá influenciar a facilidade de adição de novas ações a serem acionadas pela notificação. No momento, estão implementadas as funcionalidades de auditoria e a chamada a aplicação de um dos clientes, porém você sabe que várias outras ações serão inseridas no futuro. Atualmente condicionais no próprio código verificam as condições de execução de cada tipo de notificação, porém você deve criar um mecanismo que facilite a adição desse tipo de funcionalidade. É preciso levar em consideração que mais de uma ação pode ser realizada a partir de uma notificação e que pode haver lógicas comuns em funcionalidades de notificação diferentes. Qual será a estratégia que você irá escolher para fazer isso?","\n",["ev",{"^->":"Opcao_10.0.14.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Se você deseja criar uma superclasse para o tratamento das notificações que chama métodos abstratos para serem implementados por várias subclasses usando o padrão Template Method, vá para (19);",{"->":"$r","var":true},null]}],["ev",{"^->":"Opcao_10.0.15.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-1","flg":2},{"s":["^Se você deseja possibilitar o encadeamento dos objetos responsáveis pelo tratamento das mensagens usando o padrão Chain of Responsibility, vá para (15).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"Opcao_10.0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.14.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_19"},{"#f":5}],"c-1":["ev",{"^->":"Opcao_10.0.c-1.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.15.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_15"},{"#f":5}]}],{"#f":1}],"Opcao_11":[["^A sua decisão opta por utilizar a delegação como mecanismo para permitir a criação de novos processadores de notificação. Apenas um Message-driven Bean é responsável por realizar o processamento das notificações. Com base nas informações das mensagens, o processador de notificações utiliza regras para definir quais processadores irão compor a cadeia de processamento. Ele é responsável por montar a cadeia de responsabilidades que irá realizar de fato o processamento. Cada classe processadora é uma classe que realiza o seu processamento e em seguida delega a execução ao próximo processador da corrente.","\n","^A validação da solução agora será com a implementação das outras funcionalidades de notificação, algumas de necessidade interna da empresa, como a contabilização de acessos para fins de cobrança, e outras por solicitações dos clientes, normalmente para invocação de algum sistema deles. Existe um grande número de solicitações e os desenvolvedores irão começar a trabalhar na criação de cada uma delas. Espera-se que a estrutura adotada consiga fornecer flexibilidade para a inserção de diversos processadores diferentes da forma mais simples possível.","\n","^O primeiro passo foi refatorar a funcionalidade já existente adaptando-a para a nova estrutura. A funcionalidade de auditoria foi isolada em uma classe processadora assim como a invocação do web service do cliente. O Message-driven Bean também foi modificado para montar as cadeias de processamento com as classes processadoras. Por exemplo, o processamento de notificação de algumas funcionalidades era composto pelo registro de auditoria e a chamada do web service.","\n","^Quando os desenvolvedores começaram a desenvolver as outras funcionalidades, percebeu-se que entre diversos tipos de notificação havia grande parte da lógica em comum. Exemplos envolviam a obtenção de credenciais para o acesso aos sistemas dos clientes, criptografia de dados, validação de formato, transformação de mensagens, registro de erros ocorridos, entre outros. Com a cadeia de responsabilidades, foi possível reaproveitar componentes já existentes facilmente para compor a cadeia de processamento.","\n","^Um problema dessa abordagem foi que a montagem das cadeias começou a gerar uma grande quantidade de código condicional no Message-driven Bean. A solução encontrada foi a criação de um descritor XML com a definição das cadeias de processamento e as regras de inclusão ou não de determinadas classes processadoras. Esse XML é lido pelo Message-driven Bean em sua inicialização, que já monta todas as cadeias de processamento. A inclusão do XML além de desacoplar as classes processadoras do Message-driven bean, tornou simples adicionar ou remover um passo do processamento, aumentando a flexibilidade do mecanismo implantado.","\n","^Como resultado final foram criadas diversas classes processadoras, algumas específicas de alguns clientes e outras mais gerais, que eram utilizadas para compor as cadeias de execução. Isso evitou a repetição de código dentre diferentes processamentos de notificação e permitiu um rápido desenvolvimento de muitas funcionalidades. O XML criado para a definição das cadeias ajudou no seu gerenciamento, tornando simples a manutenção e adição de funcionalidades.","\n","^Apesar de ter cometido um engano na sua primeira decisão, você conseguiu recuperar a confiança dos desenvolvedores e da gerência com suas escolhas seguintes. Os desenvolvedores ficam satisfeitos em não precisarem realizar tarefas braçais e repetitivas para implementação dos processadores de notificação como foi na primeira parte do projeto. A gerência parece estar satisfeita com o resultado e ter esquecido um pouco a decepção inicial, visto que consegue facilmente agregar novos mecanismos de notificação, satisfazendo os clientes (e podendo cobrar mais deles) de forma ágil.","\n",["ev",{"^->":"Opcao_11.0.14.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Um dia, o gerente de TI da AvajOdnum te chama na sala dele para uma conversa... Vá para (6).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"Opcao_11.0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.14.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_6"},{"#f":5}]}],{"#f":1}],"Opcao_12":["^Quando você entra na sala do gerente, ele é todo sorriso e pede rapidamente para você se sentar. Ele te trata como se fossem grandes amigos! Após fazer algumas perguntas sem muita importância para quebrar o gelo, ele diz que o motivo de ter te chamado era para falar do seu desempenho até o momento e falar sobre o seu futuro na empresa:","\n","^\"Nós aqui na AvajOdnum achamos que o seu desempenho ficou muito acima de nossas expectativas iniciais. Todas suas decisões na arquitetura foram acertadas e a funcionalidade ficou pronta muito antes do que nós esperávamos. Os desenvolvedores todos comentam pelos cantos da empresa a respeito de como você é inteligente e saca muito de Java e de arquitetura.\"","\n","^Você balança a cabeça com ucerto orgulho, mas tentando demonstrar um pouco de humildade, e ele continua:","\n","^\"Estamos em um processo de expansão na qual estamos adquirindo outra empresa e precisaremos integrar os nossos sistemas com os sistemas deles. Para isso, estamos criando a posição de arquiteto corporativo em nossa empresa a qual queremos que você assuma. Outros arquitetos irão ser responsáveis pelas aplicações individualmente, mas será você quem terá uma visão geral das aplicações da empresa e todas as decisões importantes devem passar por você. Obviamente haverá uma compensação financeira por esse aumento de responsabilidade.\"","\n","^A conversa segue por aproximadamente uma hora e ele comenta mais detalhes sobre a expansão da empresa, indicações de pessoas para assumirem as posições de arquiteto e o quanto o seu salário irá aumentar. Você sai da conversa satisfeito e motivado para continuar o trabalho na área de arquitetura, porém reconhece que é importante nunca parar de aprender!","\n","end",{"#f":1}],"Opcao_13":[["^A sua decisão opta por utilizar a herança como mecanismo para permitir a criação de novos processadores de notificação. Para a solução, criou-se uma classe abstrata que possui no método onMessage() um algoritmo genérico para processamento das mensagens, que chama métodos abstratos que devem ser implementados pelas subclasses conforme o padrão Template Method. Para o container, cada subclasse que implementa o processador abstrato é considerado um Message-driven Bean diferente e precisa ser considerado individualmente. O interceptor Notificador irá setar nas mensagens algumas propriedades, como a funcionalidade e o cliente responsável por aquela invocação, que irão permitir que cada Messagedriven Bean filtre apenas as mensagens que são do seu interesse.","\n","^A validação da solução agora será com a implementação das outras funcionalidades de notificação, algumas de necessidade interna da empresa, como a contabilização de acessos para fins de cobrança, e outras por solicitações dos clientes, normalmente para invocação de algum sistema deles. Existe um grande número de solicitações e os desenvolvedores irão começar a trabalhar na criação de cada uma delas. Espera-se que a estrutura adotada consiga fornecer flexibilidade para a inserção de diversos processadores diferentes da forma mais simples possível.","\n","^O primeiro passo foi refatorar a funcionalidade já existente adaptandoa para a nova estrutura. O interceptor foi modificado para configurar propriedades nas mensagens para permitir que cada Message-driven Bean possa filtrar apenas as que deve tratar. O processador abstrato implementou o método onMessage() com algum processamento comum e chamando alguns métodos abstratos. A parte de auditoria foi colocada em um bean sem filtro e a chamada ao web service do cliente em um bean que filtrava somente as mensagens relativas àquele cliente. Para essas duas funcionalidades, a solução funcionou bem.","\n","^Quando os desenvolvedores começaram a desenvolver as outras funcionalidades, percebeu-se que entre diversos tipos de notificação havia grande parte da lógica em comum. Exemplos envolviam a obtenção de credenciais para o acesso aos sistemas dos clientes, criptografia de dados, validação de formato, transformação de mensagens, registro de erros ocorridos, entre outros. A princípio tentou-se repetir a estratégia do padrão Template Method, criando superclasses que implementavam essas funcionalidades e chamavam métodos abstratos que seriam implementados nas subclasses. Foi criado, por exemplo, uma classe abstrata que incorporava o registro de erros e outra que incorporava a busca das credenciais de acesso. Houve um momento em que um desenvolvedor disse que o processador de notificação que estava criando precisava das duas funcionalidades e perguntou qual das duas superclasses ele deveria estender. Neste momento, você se lembrou de uma frase que leu no livro Implementation Patterns de Kent Beck: a herança é uma carta que você só pode jogar uma vez.","\n","^O resultado final foi que a profundidade de herança dos processadores ficou muito grande, com a presença de bastante código duplicado e hierarquias de classe paralelas. Existiam também muitos Message-driven Beans consumindo mensagens na mesma fila. Apesar disso ainda não ter se tornado um problema, um arquiteto de outro projeto afirmou que isso não é bom para escalabilidade, visto que fica difícil ajustar a quantidade de beans que irá processar notificações em paralelo no container. Com essa estrutura, por exemplo, é difícil saber quais os notificadores que tratam uma determinada mensagem.","\n","^Devido ao seu resultado inicial promissor, existia uma grande expectativa que você conseguiria finalizar a solução provento uma forma simples e fácil de adicionar novos processadores. Devido ao grande número de classes, da duplicação de código e da profundidade da hierarquia, o código dos processadores é difícil de ser criado, mantido e gerenciado. A gerência se decepciona, pois isso gera uma dificuldade adicional na integração com os sistemas dos clientes, o que é um ponto muito importante no plano estratégico da empresa para conquistar novos clientes e manter os clientes antigos.","\n",["ev",{"^->":"Opcao_13.0.12.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Um dia, o gerente de TI da AvajOdnum te chama na sala dele para uma conversa... Vá para (6).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"Opcao_13.0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.12.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_6"},{"#f":5}]}],{"#f":1}],"Opcao_14":[["^A sua decisão opta por utilizar a herança como mecanismo para permitir a criação de novos processadores de notificação. Para a solução, criou-se uma classe abstrata que possui um método para o processamento das notificações com um algoritmo genérico, que chama métodos abstratos que devem ser implementados pelas subclasses conforme o padrão Template Method. O serviço de notificação é o responsável por identificar qual a subclasse que deverá processar cada notificação recebida e utiliza as informações do usuário e da invocação (session bean, método, parâmetros) para fazer isso.","\n","^A validação da solução agora será com a implementação das outras funcionalidades de notificação, algumas de necessidade interna da empresa, como a contabilização de acessos para fins de cobrança, e outras por solicitações dos clientes, normalmente para invocação de algum sistema deles. Existe um grande número de solicitações e os desenvolvedores irão começar a trabalhar na criação de cada uma delas. Espera-se que a estrutura adotada consiga fornecer flexibilidade para a inserção de diversos processadores diferentes da forma mais simples possível.","\n","^O primeiro passo foi refatorar a funcionalidade já existente adaptando-a para a nova estrutura. O processador abstrato implementou o método processarNotificacao() com algum processamento comum e chamando alguns métodos abstratos. A parte de auditoria foi colocada em uma subclasse do processador abstrato. Como todas as funcionalidades que precisavam da chamada do web service também precisavam do registro de auditoria, esse processador estendeu a classe que fazia auditoria. Para essas duas funcionalidades, a solução funcionou bem.","\n","^Quando os desenvolvedores começaram a desenvolver as outras funcionalidades, percebeu-se que entre diversos tipos de notificação havia grande parte da lógica em comum. Exemplos envolviam a obtenção de credenciais para o acesso aos sistemas dos clientes, criptografia de dados, validação de formato, transformação de mensagens, registro de erros ocorridos, entre outros. A princípio tentou-se repetir a estratégia do padrão Template Method, criando superclasses que implementavam essas funcionalidades e chamavam métodos abstratos que seriam implementados nas subclasses. Foram criadas, por exemplo, uma classe abstrata que incorporava o registro de erros e outra que incorporava a busca das credenciais de acesso. Houve um momento em que um desenvolvedor disse que o processador de notificação que estava criando precisava das duas funcionalidades e perguntou qual das duas superclasses ele deveria estender. Neste momento, você se lembrou de uma frase que leu no livro Implementation Patterns de Kent Beck: a herança é uma carta que você só pode jogar uma vez.","\n","^Devido a lógica de identificação da classe de processamento no session bean ter ficado muito complicada, foi criado um arquivo XML para o mapeamento das chamadas para o processador. A profundidade de herança dos processadores ficou muito grande, com a presença de muito código duplicado e hierarquias de classe paralelas. Existiam tantas particularidades que era raro uma classe de processamento ser utilizada para mais de um tipo de notificação.","\n","^Suas escolhas foram um desastre desde o começo. Muito trabalho braçal, degradação do desempenho, dificuldade de manutenção. Todos esses indesejáveis fatores fizeram com que os desenvolvedores ficassem muito desmotivados em trabalhar nesse projeto. A gerência fica descontente ao notar que existe uma dificuldade generalizada na integração do mecanismo com os sistemas dos clientes.","\n",["ev",{"^->":"Opcao_14.0.12.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Um dia, o gerente de TI da AvajOdnum te chama na sala dele para uma conversa... Vá para (9).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"Opcao_14.0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.12.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_9"},{"#f":5}]}],{"#f":1}],"Opcao_15":[["^A sua decisão opta por utilizar a delegação como mecanismo para permitir a criação de novos processadores de notificação. Com base nas informações das mensagens, o serviço de notificação utiliza regras para definir quais processadores irão compor a cadeia de processamento. Ele é responsável por montar a cadeia de responsabilidades que irá realizar de fato o processamento. Cada classe processadora é uma classe que realiza o seu processamento e em seguida delega a execução ao próximo processador da corrente.","\n","^A validação da solução agora será com a implementação das outras funcionalidades de notificação, algumas de necessidade interna da empresa, como a contabilização de acessos para fins de cobrança, e outras por solicitações dos clientes, normalmente para invocação de algum sistema deles. Existe um grande número de solicitações e os desenvolvedores irão começar a trabalhar na criação de cada uma delas. Espera-se que a estrutura adotada consiga fornecer flexibilidade para a inserção de diversos processadores diferentes da forma mais simples possível.","\n","^O primeiro passo foi refatorar a funcionalidade já existente adaptando-a para a nova estrutura. A funcionalidade de auditoria foi isolada em uma classe processadora assim como a invocação do web service do cliente. O Session Bean com o serviço de notificação também foi modificado para montar as cadeias de processamento com as classes processadoras. Por exemplo, o processamento de notificação de algumas funcionalidades era composto pelo registro de auditoria e a chamada do web service.","\n","^Quando os desenvolvedores começaram a desenvolver as outras funcionalidades, percebeu-se que entre diversos tipos de notificação havia grande parte da lógica em comum. Exemplos envolviam a obtenção de credenciais para o acesso aos sistemas dos clientes, criptografia de dados, validação de formato, transformação de mensagens, registro de erros ocorridos, entre outros. Com a cadeia de responsabilidades, foi possível reaproveitar componentes já existentes facilmente para compor a cadeia de processamento.","\n","^Um problema dessa abordagem foi que a montagem das cadeias começou a gerar uma grande quantidade de código condicional no Session Bean. A solução encontrada foi a criação de um descritor XML com a definição das cadeias de processamento e as regras de inclusão ou não de determinadas classes processadoras. Esse XML é lido pelo Session Bean com o serviço de notificação em sua inicialização, que já monta todas as cadeias de processamento. A inclusão do XML além de desacoplar as classes processadoras do serviço de notificação, tornou simples adicionar ou remover um passo do processamento, aumentando a flexibilidade do mecanismo implantado.","\n","^Como resultado final, foram criadas diversas classes processadoras, algumas específicas de alguns clientes e outras mais gerais, que eram utilizadas para compor as cadeias de execução. Isso evitou a repetição de código dentre diferentes processamentos de notificação e permitiu um rápido desenvolvimento de muitas funcionalidades. O XML criado para a definição das cadeias ajudou no seu gerenciamento, tornando simples a manutenção e adição de funcionalidades.","\n","^Apesar do sistema de notificação ter degradado o desempenho da aplicação, você conseguiu fazer com que ele pudesse ser facilmente acoplado no sistema existente e que novos processadores pudessem ser facilmente introduzidos. Os desenvolvedores ficam satisfeitos em não precisarem realizar tarefas braçais e repetitivas em nenhuma fase do projeto, tendo consciência que estavam trabalhando em cima de uma boa estrutura. A gerência parece estar satisfeita com o resultado e ter esquecido um pouco da demora nas requisições, visto que consegue facilmente agregar novos mecanismos de notificação, satisfazendo os clientes (e podendo cobrar mais deles) de forma ágil. Quem sabe com essa boa estrutura você não consegue refatorar alguma coisa para resolver esse problema do desempenho.","\n",["ev",{"^->":"Opcao_15.0.14.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Um dia, o gerente de TI da AvajOdnum te chama na sala dele para uma conversa... Vá para (6).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"Opcao_15.0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.14.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_6"},{"#f":5}]}],{"#f":1}],"Opcao_16":[["^A sua decisão opta por utilizar a herança como mecanismo para permitir a criação de novos processadores de notificação. Para a solução, criou-se uma classe abstrata que possui no método onMessage() um algoritmo genérico para processamento das mensagens, que chama métodos abstratos que devem ser implementados pelas subclasses conforme o padrão Template Method. Para o container, cada subclasse que implementa o processador abstrato é considerado um Message-driven Bean diferente e precisa ser considerado individualmente. O interceptor Notificador irá setar nas mensagens algumas propriedades, como a funcionalidade e o cliente responsável por aquela invocação, que irão permitir que cada Message-driven Bean filtre apenas as mensagens que são do seu interesse.","\n","^A validação da solução agora será com a implementação das outras funcionalidades de notificação, algumas de necessidade interna da empresa, como a contabilização de acessos para fins de cobrança, e outras por solicitações dos clientes, normalmente para invocação de algum sistema deles. Existe um grande número de solicitações e os desenvolvedores irão começar a trabalhar na criação de cada uma delas. Espera-se que a estrutura adotada consiga fornecer flexibilidade para a inserção de diversos processadores diferentes da forma mais simples possível.","\n","^O primeiro passo foi refatorar a funcionalidade já existente adaptando-a para a nova estrutura. O interceptor foi modificado para configurar propriedades nas mensagens para permitir que cada Message-driven Bean possa filtrar apenas as que deve tratar. O processador abstrato implementou o método onMessage() com algum processamento comum e chamando alguns métodos abstratos. A parte de auditoria foi colocada em um bean sem filtro e a chamada ao web service do cliente em um bean que filtrava somente as mensagens relativas àquele cliente. Para essas duas funcionalidades, a solução funcionou bem.","\n","^Quando os desenvolvedores começaram a desenvolver as outras funcionalidades, percebeu-se que entre diversos tipos de notificação havia grande parte da lógica em comum. Exemplos envolviam a obtenção de credenciais para o acesso aos sistemas dos clientes, criptografia de dados, validação de formato, transformação de mensagens, registro de erros ocorridos, entre outros. A princípio, tentou-se repetir a estratégia do padrão Template Method, criando superclasses que implementavam essas funcionalidades e chamavam métodos abstratos que seriam implementados nas subclasses. Foi criado, por exemplo, uma classe abstrata que incorporava o registro de erros e outra que incorporava a busca das credenciais de acesso. Houve um momento em que um desenvolvedor disse que o processador de notificação que estava criando precisava das duas funcionalidades e perguntou qual das duas superclasses ele deveria estender. Neste momento, você se lembrou de uma frase que leu no livro Implementation Patterns de Kent Beck: a herança é uma carta que você só pode jogar uma vez.","\n","^O resultado final foi que a profundidade de herança dos processadores ficou muito grande, com a presença de bastante código duplicado e hierarquias de classe paralelas. Existiam também muitos Message-driven Beans consumindo mensagens na mesma fila. Apesar disso ainda não ter se tornado um problema, um arquiteto de outro projeto afirmou que isso não é bom para escalabilidade, visto que fica difícil ajustar a quantidade de beans que irá processar notificações em paralelo no container. Com essa estrutura, por exemplo, é difícil de saber quais os notificadores que tratam uma determinada mensagem.","\n","^Você havia se recuperado de seu primeiro erro com a utilização das chamadas assíncronas para não permitir a degradação do desempenho com as notificações, porém essa última decisão foi uma decepção para todos. Devido ao grande número de classes, da duplicação de código e da profundidade da hierarquia, o código dos processadores é difícil de ser criado, mantido e gerenciado. A gerência nota que existe uma dificuldade adicional na integração com os sistemas dos clientes, o que é um ponto muito importante no plano estratégico da empresa para conquistar novos clientes e manter os clientes antigos.","\n",["ev",{"^->":"Opcao_16.0.12.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Um dia, o gerente de TI da AvajOdnum te chama na sala dele para uma conversa... Vá para (18).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"Opcao_16.0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.12.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_18"},{"#f":5}]}],{"#f":1}],"Opcao_17":[["^A sua decisão opta por utilizar a delegação como mecanismo para permitir a criação de novos processadores de notificação. Apenas um Message-driven Bean é responsável por realizar o processamento das notificações. Com base nas informações das mensagens, o processador de notificações utiliza regras para definir quais processadores irão compor a cadeia de processamento. Ele é responsável por montar a cadeia de responsabilidades que irá realizar de fato o processamento. Cada classe processadora é uma classe que realiza o seu processamento e em seguida delega a execução ao próximo processador da corrente.","\n","^A validação da solução agora será com a implementação das outras funcionalidades de notificação, algumas de necessidade interna da empresa, como a contabilização de acessos para fins de cobrança, e outras por solicitações dos clientes, normalmente para invocação de algum sistema deles. Existe um grande número de solicitações e os desenvolvedores irão começar a trabalhar na criação de cada uma delas. Espera-se que a estrutura adotada consiga fornecer flexibilidade para a inserção de diversos processadores diferentes da forma mais simples possível.","\n","^O primeiro passo foi refatorar a funcionalidade já existente adaptando-a para a nova estrutura. A funcionalidade de auditoria foi isolada em uma classe processadora assim como a invocação do web service do cliente. O Message-driven Bean também foi modificado para montar as cadeias de processamento com as classes processadoras. Por exemplo, o processamento de notificação de algumas funcionalidades era composto pelo registro de auditoria e a chamada do web service.","\n","^Quando os desenvolvedores começaram a desenvolver as outras funcionalidades, percebeu-se que entre diversos tipos de notificação havia grande parte da lógica em comum. Exemplos envolviam a obtenção de credenciais para o acesso aos sistemas dos clientes, criptografia de dados, validação de formato, transformação de mensagens, registro de erros ocorridos, entre outros. Com a cadeia de responsabilidades foi possível reaproveitar componentes já existentes facilmente para compor a cadeia de processamento.","\n","^Um problema dessa abordagem foi que a montagem das cadeias começou a gerar uma grande quantidade de código condicional no Messagedriven Bean. A solução encontrada foi a criação de um descritor XML com a definição das cadeias de processamento e as regras de inclusão ou não de determinadas classes processadoras. Esse XML é lido pelo Message-driven Bean em sua inicialização, que já monta todas as cadeias de processamento. A inclusão do XML além de desacoplar as classes processadoras do Message-driven bean, tornou simples adicionar ou remover um passo do processamento, aumentando a flexibilidade do mecanismo implantado.","\n","^Como resultado final, foram criadas diversas classes processadoras, algumas específicas de alguns clientes e outras mais gerais, que eram utilizadas para compor as cadeias de execução. Isso evitou a repetição de código dentre diferentes processamentos de notificação e permitiu um rápido desenvolvimento de muitas funcionalidades. O XML criado para a definição das cadeias ajudou no seu gerenciamento, tornando simples a manutenção e adição de funcionalidades.","\n","^Ao olhar para o resultado final do mecanismo de notificação você se orgulha de suas decisões e fica com uma sensação de dever cumprido. Os desenvolvedores ficam satisfeitos por estarem trabalhando em projeto em que podem se focar no desenvolvimento de funcionalidades que agregam valor ao projeto sem precisarem realizar tarefas braçais e repetitivas. A gerência parece estar satisfeita com o resultado, visto que consegue facilmente agregar novos mecanismos de notificação, satisfazendo os clientes (e podendo cobrar mais deles) de forma ágil.","\n",["ev",{"^->":"Opcao_17.0.14.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Um dia, o gerente de TI da AvajOdnum te chama na sala dele para uma conversa... Vá para (12).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"Opcao_17.0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.14.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_12"},{"#f":5}]}],{"#f":1}],"Opcao_18":["^Quando você entra na sala do gerente, ele está trabalhando em seu computador. Ele a princípio parece ignorar sua presença, mas em seguida volta-se para você encarando-o com uma expressão bem séria. Ele pede para você se sentar e sem fazer muitos rodeios diz que o motivo de ter te chamado era para falar do seu desempenho até o momento e falar sobre o seu futuro na empresa:","\n","^\"Nós aqui na AvajOdnum achamos que o seu desempenho ficou abaixo de nossas expectativas iniciais. Apesar de você ter acertado em algumas escolhas para a implementação do mecanismo de notificação de um de nossos sistemas, você mesmo sabe que a maioria delas poderiam ser melhores. Várias de suas decisões tornaram complexa a edição de novas funcionalidades no sistema.\"","\n","^Você balança a cabeça admitindo que errou em vários pontos e ele continua:","\n","^\"Por outro lado, sabemos que no que diz respeito a implementação você demonstrou conhecimento em diversas tecnologias e que é eficiente na criação de código. Apesar de acharmos que você ainda não tem experiência para se tornar um arquiteto, se você se interessar gostaríamos que continuasse fazendo parte da equipe como desenvolvedor. É claro que vai ganhar um pouco menos, porém acredito que terá várias oportunidades para aprender.\"","\n","^Você fica um pouco chateado por não ter dado conta de cumprir de forma satisfatória com a função de arquiteto que havia lhe sido dada. Por outro lado, você sente certo alívio por ainda ter um emprego. Em situações como esta é que é preciso ter humildade, reconhecer suas limitações e estudar bastante para chegar no ponto em que se almeja. Quem sabe daqui a algum tempo você não consegue recuperar a posição que perdeu. Você escuta conversas de corredor que a empresa está se expandindo e oportunidades não irão faltar.","\n","end",{"#f":1}],"Opcao_19":[["^A sua decisão opta por utilizar a herança como mecanismo para permitir a criação de novos processadores de notificação. Para a solução, criou-se uma classe abstrata que possui um método para o processamento das notificações com um algoritmo genérico, que chama métodos abstratos que devem ser implementados pelas subclasses conforme o padrão Template Method. O serviço de notificação é o responsável por identificar qual a subclasse que deverá processar cada notificação recebida e utiliza as informações do usuário e da invocação (session bean, método, parâmetros) para fazer isso.","\n","^A validação da solução agora será com a implementação das outras funcionalidades de notificação, algumas de necessidade interna da empresa, como a contabilização de acessos para fins de cobrança, e outras por solicitações dos clientes, normalmente para invocação de algum sistema deles. Existe um grande número de solicitações e os desenvolvedores irão começar a trabalhar na criação de cada uma delas. Espera-se que a estrutura adotada consiga fornecer flexibilidade para a inserção de diversos processadores diferentes da forma mais simples possível.","\n","^O primeiro passo foi refatorar a funcionalidade já existente adaptando-a para a nova estrutura. O interceptor não precisou ser modificado, pois já enviava as informações necessárias para o serviço de notificação escolher a classe que irá fazer o processamento. O processador abstrato implementou o método processarNotificacao() com algum processamento comum e chamando alguns métodos abstratos. A parte de auditoria foi colocada em uma subclasse do processador abstrato. Como todas as funcionalidades que precisavam da chamada do web service também precisavam do registro de auditoria, esse processador estendeu a classe que fazia auditoria. Para essas duas funcionalidades, a solução funcionou bem.","\n","^Quando os desenvolvedores começaram a desenvolver as outras funcionalidades, percebeu-se que entre diversos tipos de notificação havia grande parte da lógica em comum. Exemplos envolviam a obtenção de credenciais para o acesso aos sistemas dos clientes, criptografia de dados, validação de formato, transformação de mensagens, registro de erros ocorridos, entre outros. A princípio, tentou-se repetir a estratégia do padrão Template Method, criando superclasses que implementavam essas funcionalidades e chamavam métodos abstratos que seriam implementados nas subclasses. Foi criado, por exemplo, uma classe abstrata que incorporava o registro de erros e outra que incorporava a busca das credenciais de acesso. Houve um momento em que um desenvolvedor disse que o processador de notificação que estava criando precisava das duas funcionalidades e perguntou qual das duas superclasses ele deveria estender. Neste momento, você se lembrou de uma frase que leu no livro Implementation Patterns de Kent Beck: a herança é uma carta que você só pode jogar uma vez.","\n","^Devido a lógica de identificação da classe de processamento no session bean ter ficado muito complicada, foi criado um arquivo XML para o mapeamento das chamadas para o processador. A profundidade de herança dos processadores ficou muito grande, com a presença de bastante código duplicado e hierarquias de classe paralelas. Existiam tantas particularidades que era muito raro uma classe de processamento ser utilizada para mais de um tipo de notificação.","\n","^Você havia começado bem com a escolha do uso dos interceptors, porém as duas últimas decisões foram uma decepção para todos. Devido ao grande número de classes, da duplicação de código e da profundidade da hierarquia, o código dos processadores é difícil de ser criado, mantido e gerenciado. A gerência nota que existe uma dificuldade adicional na integração com os sistemas dos clientes, o que é um ponto muito importante no plano estratégico da empresa para conquistar novos clientes e manter os clientes antigos.","\n",["ev",{"^->":"Opcao_19.0.12.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Um dia, o gerente de TI da AvajOdnum te chama na sala dele para uma conversa... Vá para (18).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"Opcao_19.0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.12.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_18"},{"#f":5}]}],{"#f":1}],"Opcao_20":[["^A sua decisão opta por utilizar a delegação como mecanismo para permitir a criação de novos processadores de notificação. Com base nas informações das mensagens, o serviço de notificação utiliza regras para definir quais processadores irão compor a cadeia de processamento. Ele é responsável por montar a cadeia de responsabilidades que irá realizar de fato o processamento. Cada classe processadora é uma classe que realiza o seu processamento e em seguida delega a execução ao próximo processador da corrente.","\n","^A validação da solução agora será com a implementação das outras funcionalidades de notificação, algumas de necessidade interna da empresa, como a contabilização de acessos para fins de cobrança, e outras por solicitações dos clientes, normalmente para invocação de algum sistema deles. Existe um grande número de solicitações e os desenvolvedores irão começar a trabalhar na criação de cada uma delas. Espera-se que a estrutura adotada consiga fornecer flexibilidade para a inserção de diversos processadores diferentes da forma mais simples possível.","\n","^O primeiro passo foi refatorar a funcionalidade já existente adaptando-a para a nova estrutura. A funcionalidade de auditoria foi isolada em uma classe processadora assim como a invocação do web service do cliente. O Session Bean com o serviço de notificação também foi modificado para montar as cadeias de processamento com as classes processadoras. Por exemplo, o processamento de notificação de algumas funcionalidades era composto pelo registro de auditoria e a chamada do web service.","\n","^Quando os desenvolvedores começaram a desenvolver as outras funcionalidades, percebeu-se que entre diversos tipos de notificação havia grande parte da lógica em comum. Exemplos envolviam a obtenção de credenciais para o acesso aos sistemas dos clientes, criptografia de dados, validação de formato, transformação de mensagens, registro de erros ocorridos, entre outros. Com a cadeia de responsabilidades foi possível reaproveitar componentes já existentes facilmente para compor a cadeia de processamento.","\n","^Um problema dessa abordagem foi que a montagem das cadeias começou a gerar uma grande quantidade de código condicional no Session Bean. A solução encontrada foi a criação de um descritor XML com a definição das cadeias de processamento e as regras de inclusão ou não de determinadas classes processadoras. Esse XML é lido pelo Session Bean com o serviço de notificação em sua inicialização, que já monta todas as cadeias de processamento. A inclusão do XML além de desacoplar as classes processadoras do serviço de notificação, tornou simples adicionar ou remover um passo do processamento, aumentando a flexibilidade do mecanismo implantado.","\n","^Como resultado final foram criadas diversas classes processadoras, algumas específicas de alguns clientes e outras mais gerais, que eram utilizadas para compor as cadeias de execução. Isso evitou a repetição de código dentre diferentes processamentos de notificação e permitiu um rápido desenvolvimento de muitas funcionalidades. O XML criado para a definição das cadeias ajudou no seu gerenciamento, tornando simples a manutenção e adição de funcionalidades.","\n","^Os problemas provenientes das suas duas primeiras decisões fizeram que sua credibilidade como arquiteto ficasse em baixa, porém essa última escolha levantou sua moral com a equipe e com a gerência. Os desenvolvedores ficam satisfeitos em não precisarem realizar tarefas braçais e repetitivas na inserção dos processadores. A gerência parece estar satisfeita com o resultado dessa fase, visto que consegue facilmente agregar novos mecanismos de notificação, satisfazendo os clientes (e podendo cobrar mais deles) de forma ágil.","\n",["ev",{"^->":"Opcao_20.0.14.$r1"},{"temp=":"$r"},"str",{"->":".^.s"},[{"#n":"$r1"}],"/str","/ev",{"*":".^.^.c-0","flg":2},{"s":["^Um dia, o gerente de TI da AvajOdnum te chama na sala dele para uma conversa... Vá para (18).",{"->":"$r","var":true},null]}],{"c-0":["ev",{"^->":"Opcao_20.0.c-0.$r2"},"/ev",{"temp=":"$r"},{"->":".^.^.14.s"},[{"#n":"$r2"}],"\n",{"->":"Opcao_18"},{"#f":5}]}],{"#f":1}],"#f":1}],"listDefs":{}}